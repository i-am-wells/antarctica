
local ant = require 'antarctica'
local Engine = require 'engine'
local Tilemap = require 'tilemap'
local Image = require 'image'

local drawTerrain = require 'mapeditor.drawterrain'

local white = {r=255, g=255, b=255, a=255}

local editor = function(engine, tilemap, tileset, mapFilename)
    --local screenW, screenH = engine:getLogicalSize()
    local screenW, screenH = engine:getSize()
    local viewScale = 1
    print(screenW, screenH)

    local mapSelection = {l=0, x=0, y=0, w=1, h=1}
    local paletteSelection = {x=0, y=0, w=1, h=1}
    local mapSel0, paletteSel0 = {x=0, y=0}, {x=0, y=0}

    local bgcolor = {r=0, g=0, b=0, a=255}
    local paletteBorderColor = {r=255, g=0, b=0, a=255}
    local setColor = function(color)
        engine:setColor(color.r, color.g, color.b, color.a)
    end

    local getPaletteRect = function()
        return {
            x=((screenW // viewScale) - tileset.w - 1), 
            y=((screenH // viewScale) - tileset.h - 1), 
            w=(tileset.w + 2), 
            h=(tileset.h + 2)
        }
    end
    local paletteRect = getPaletteRect()

    local drawRect = function(rect)
        engine:drawRect(rect.x, rect.y, rect.w, rect.h)
    end
    
    local font = Image{file = 'res/text-6x12.png', tilew = 6, tileh = 12, engine = engine}

    local editLayer = 0
    local layerMask = {}
    for l = 0, (tilemap.nlayers - 1) do
        layerMask[l] = true
    end
    local mapx, mapy = 0, 0
    local mouseX, mouseY = 0, 0

    local isMouseDown, isShift, isCtrl = false, false, false
    local isSelectingMap, isSelectingPalette = false, false
    local showPalette, showInfoText, showFlags = false, false, false
    local isLive, needsRedraw = true, true
    
    -- terrain drawing mode
    local isDrawingTerrain = false
    local terrainDir = 'e'

    local flagMask = 0

    local undoStack = {}
    local clipboard

    local scaleXY = function(x, y)
        return (x / viewScale), (y / viewScale)
    end

    local screentomap = function(x, y)
        x, y = scaleXY(x, y)
        return (mapx + x // (tileset.tw)), (mapy + y // (tileset.th))
    end
    local screentopalette = function(x, y)
        x, y = scaleXY(x, y)
        return ((x - (paletteRect.x + 1)) // (tileset.tw)), ((y - (paletteRect.y + 1)) // (tileset.th))
    end

    local redraw = function()
        needsRedraw = true
    end

    local updateSelection = function(screenX, screenY, isPalette)
        local mx, my, selection, sel0
        if isPalette then
            mx, my = screentopalette(screenX, screenY)
            selection = paletteSelection
            sel0 = paletteSel0
        else
            mx, my = screentomap(screenX, screenY)
            selection = mapSelection
            sel0 = mapSel0
        end

        selection.x = math.min(mx, sel0.x)
        selection.w = math.max(mx, sel0.x) - selection.x + 1
        selection.y = math.min(my, sel0.y)
        selection.h = math.max(my, sel0.y) - selection.y + 1
    
        -- trim to boundaries
        selection.x = math.max(selection.x, 0)
        selection.y = math.max(selection.y, 0)
        if isPalette then
            selection.w = math.min(selection.w, (tileset.w // tileset.tw) - selection.x)
            selection.h = math.min(selection.h, (tileset.h // tileset.th) - selection.y)
        else
            selection.w = math.min(selection.w, tilemap.w - selection.x)
            selection.h = math.min(selection.h, tilemap.h - selection.y)
        end

        redraw()
    end

    local toggleLayer = function(layerNum)
        if (layerNum > -1) and (layerNum < tilemap.nlayers) then
            layerMask[layerNum] = not layerMask[layerNum]
            redraw()
        end
    end

    -- 
    -- Editing control routines
    --
    local edit
    edit = {
        floodFillTiles = function()
            -- flood fill using top left corner of palette selection
            local stack = {{mapSelection.x, mapSelection.y}}
            local origTx, origTy = tilemap:getTile(editLayer, mapSelection.x, mapSelection.y)

            -- stop right now if new tile is the same as original
            if (paletteSelection.x == origTx) and (paletteSelection.y == origTy) then
                return
            end

            local isFirst = true
            while #stack > 0 do
                -- pop
                local popped = stack[#stack]
                stack[#stack] = nil

                -- set tile
                local mapX, mapY = popped[1], popped[2]
                edit.pushUndo({x=mapX, y=mapY, w=1, h=1}, isFirst)
                isFirst = false
                tilemap:setTile(editLayer, mapX, mapY, paletteSelection.x, paletteSelection.y)

                -- push neighbors
                for _, p in ipairs{{1,0},{0,-1},{-1,0},{0,1}} do
                    local newX, newY = mapX + p[1], mapY + p[2]
                    local tx, ty = tilemap:getTile(editLayer, newX, newY)

                    -- is it the original "color"?
                    if (tx == origTx) and (ty == origTy) then
                        table.insert(stack, {newX, newY})
                    end
                end
            end
        end,
        drawTilesFromPalette = function(isFirst)
            -- Draw one patch (paletteSelection) to the corner of map selection
            local boundX = math.min(paletteSelection.w, tilemap.w - mapSelection.x) - 1
            local boundY = math.min(paletteSelection.h, tilemap.h - mapSelection.y) - 1
            local layer = editLayer

            edit.pushUndo(
                {x=mapSelection.x, y=mapSelection.y, w=(boundX+1), h=(boundY+1)}, 
                isFirst
            )
            -- map and tiles are zero-indexed
            for y = 0, boundY do
                for x = 0, boundX do
                    tilemap:setTile(
                        layer, 
                        mapSelection.x + x, 
                        mapSelection.y + y, 
                        paletteSelection.x + x, 
                        paletteSelection.y + y
                    )
                end
            end

            redraw()
        end,
        drawTerrain = function(oldX, oldY, mapx, mapy)
            
            -- check if it's a valid move and get the direction
            local newDir = drawTerrain.getMoveDirection(oldX, oldY, mapx, mapy, terrainDir)
            if newDir then
                drawTerrain.drawTerrain(tilemap, terrainDir, newDir, oldX, oldY, mapx, mapy, true)
                terrainDir = newDir
            end
        end,
        drawBumpFlagsToggle = function(isFirst)
            local layer = editLayer

            edit.pushUndo(mapSelection, isFirst)

            -- map and tiles are zero-indexed
            for y = 0, mapSelection.h - 1 do
                for x = 0, mapSelection.w - 1 do
                    tilemap:overwriteFlags(
                        layer, 
                        mapSelection.x + x, 
                        mapSelection.y + y, 
                        flagMask
                    )
                end
            end

            redraw()
            
        end,
        undo = function()
            -- Seek back to the beginning of the most recent action and apply
            -- undo patches
            while true do
                local undoevent = undoStack[#undoStack]

                if undoevent then
                    tilemap:patch(undoevent.data, undoevent)
                    undoStack[#undoStack] = nil

                    if undoevent.mark then
                        break
                    end
                else
                    break
                end
            end
        end,
        pushUndo = function(rect, marker)
            -- Get the selected area and push
            rect.data = tilemap:export(rect)
            rect.mark = marker
            table.insert(undoStack, rect)
        end,
        copy = function()
            print('copy')
            -- copy map selection to clipboard
            clipboard = {}
            for k,v in pairs(mapSelection) do clipboard[k] = v end
            clipboard.data = tilemap:export(clipboard)
        end,
        paste = function()
            print('paste')
            if clipboard then
                clipboard.x = mouseX
                clipboard.y = mouseY
                edit.pushUndo(clipboard, true)
                tilemap:patch(clipboard.data, clipboard)
            end
        end,
    }

    -- 
    -- Key down handlers
    --
    local keyboardHandlers = setmetatable(
        {
            ['['] = function()
                editLayer = (editLayer - 1) % tilemap.nlayers
            end,
            [']'] = function()
                editLayer = (editLayer + 1) % tilemap.nlayers
            end,
            A = function()
                mapx = mapx - 1
                redraw()
            end,
            B = function()
                edit.floodFillTiles()
                redraw()
            end,
            C = function()
                if isCtrl then
                    edit.copy()
                end
            end,
            D = function()
                mapx = mapx + 1
                redraw()
            end,
            F = function()
                showFlags = not showFlags
                redraw()
            end,
            H = function()
                flagMask = flagMask ~ ant.tilemap.bumpwestflag
            end,
            I = function()
                showInfoText = not showInfoText
                redraw()
            end,
            J = function()
                flagMask = flagMask ~ ant.tilemap.bumpsouthflag
            end,
            K = function()
                flagMask = flagMask ~ ant.tilemap.bumpeastflag
            end,
            L = function()
                isLive = not isLive
                redraw()
            end,
            P = function()
                showPalette = not showPalette
                redraw()
            end,
            S = function()
                if isCtrl then
                    print('Saving to '..mapFilename..'...')
                    if tilemap:write(mapFilename) then
                        print('Saved.')
                    else
                        print('Failed!')
                    end
                else
                    mapy = mapy + 1
                    redraw()
                end
            end,
            T = function()
                isDrawingTerrain = not isDrawingTerrain
            end,
            U = function()
                flagMask = flagMask ~ ant.tilemap.bumpnorthflag
            end,
            V = function()
                if isCtrl then
                    edit.paste()
                end
            end,
            W = function()
                mapy = mapy - 1
                redraw()
            end,
            Z = function()
                if isCtrl then
                    edit.undo()
                end
            end,
            ['Left Shift'] = function()
                isShift = true
            end,
            ['Left Ctrl'] = function()
                isCtrl = true
            end,
        }, {__index = function(tbl, key) 
            local layerNum = tonumber(key)
            if layerNum ~= nil then
                return function() toggleLayer(layerNum) end
            end
                
            return function() print('unhandled key '..key) end 
        end}
    )


    engine:run{
        redraw = function(tick, frametime, counter)

            if (not isLive) and (not needsRedraw) then
                return
            end

            -- clear
            setColor(bgcolor)
            engine:clear()

            -- draw map
            for l = 0, tilemap.nlayers - 1 do
                if layerMask[l] then
                    if showFlags then
                        tilemap:drawLayerFlags(tileset, l, mapx * tileset.tw, mapy * tileset.th, screenW // viewScale, screenH // viewScale)
                    else
                        tilemap:drawLayer(tileset, l, mapx * tileset.tw, mapy * tileset.th, screenW // viewScale, screenH // viewScale, counter)
                    end
                end
            end

            -- terrain editing?
            if isDrawingTerrain then
                -- draw green squares on valid next choices
                --
                -- TODO
                engine:setColor(0, 255, 0, 127)
                for _, dir in ipairs(drawTerrain.validNextDirections(terrainDir)) do
                    local cx, cy = mapSelection.x, mapSelection.y
                    local v = drawTerrain.directions[dir]
                    while (cx > mapx) and (cy > mapy) and (cx <= (mapx + (screenW / viewScale) // tileset.tw)) and (cy <= (mapy + (screenH / viewScale) // tileset.th)) do
                        engine:fillRect(
                            (cx - mapx) * tileset.tw,
                            (cy - mapy) * tileset.th,
                            tileset.tw,
                            tileset.th
                        )
                        
                        cx = cx + v.x
                        cy = cy + v.y
                    end
                end
            end

            -- draw map selection
            setColor(bgcolor)
            engine:drawRect(
                (mapSelection.x - mapx) * tileset.tw,
                (mapSelection.y - mapy) * tileset.th,
                mapSelection.w * tileset.tw,
                mapSelection.h * tileset.th
            )

            if showPalette then
                -- draw palette border
                setColor(paletteBorderColor)
                drawRect(paletteRect)

                -- draw palette
                for paly = 0, (tileset.h // tileset.th) - 1 do
                    for palx = 0, (tileset.w // tileset.tw) - 1 do
                        tileset:drawTile(
                            palx, paly, 
                            paletteRect.x + (palx*tileset.tw) + 1,
                            paletteRect.y + (paly*tileset.th) + 1
                        )
                    end
                end
                
                -- draw palette selection
                engine:drawRect(
                    paletteRect.x + paletteSelection.x * tileset.tw + 1,
                    paletteRect.y + paletteSelection.y * tileset.th + 1,
                    paletteSelection.w * tileset.tw,
                    paletteSelection.h * tileset.th
                )
            else
                -- draw mouseover box
                setColor(bgcolor)
                engine:drawRect(
                    (mouseX - mapx) * tileset.tw,
                    (mouseY - mapy) * tileset.th,
                    tileset.tw, tileset.th
                )
            end

            if showInfoText then
                -- draw info text
                setColor(white)
                engine:fillRect(0, screenH - 12, 250, 12)
                font:drawText(
                    string.format(
                        '%d, %d (selection: layer %d - %d, %d, %dx%d), %dfps', 
                        mouseX, mouseY, editLayer,
                        mapSelection.x, mapSelection.y, mapSelection.w, mapSelection.h,
                        1000 // math.max(frametime, 16)
                    ),
                    0, screenH - 12, 250
                )
            end

            needsRedraw = false
        end,

        keydown = function(key)
            keyboardHandlers[key]()
        end,

        keyup = function(key)
            if key == 'Left Shift' then
                isShift = false
            elseif key == 'Left Ctrl' then
                isCtrl = false
            end
        end,

        mousebuttondown = function(x, y)
            isMouseDown = true
            
            -- Check if click was within palette
            if (x > paletteRect.x) and (x < screenW) and (y > paletteRect.y) and (y < screenH) and showPalette then
                -- set palette selection
                local palx, paly = screentopalette(x, y)
                paletteSel0 = {x=palx, y=paly}
                paletteSelection = {x=palx, y=paly, w=1, h=1}
                isSelectingPalette = true
            else
                local oldX, oldY = mapSelection.x, mapSelection.y

                -- set map selection
                local mapx, mapy = screentomap(x, y)
                mapSel0 = {x=mapx, y=mapy}
                mapSelection = {x=mapx, y=mapy, w=1, h=1}
                if isShift then
                    isSelectingMap = true
                else
                    -- draw from palette
                    if showFlags then
                        edit.drawBumpFlagsToggle(true)
                    else
                        if isDrawingTerrain then
                            edit.drawTerrain(oldX, oldY, mapx, mapy)
                        else
                            edit.drawTilesFromPalette(true)
                        end
                    end
                end
            end
        end,

        mousebuttonup = function(x, y)
            isMouseDown = false
            
            if isSelectingMap then
                isSelectingMap = false
                -- finish selection
                updateSelection(x, y)
            end

            if isSelectingPalette then
                isSelectingPalette = false
                updateSelection(x, y, true)
            end
        end,
        
        mousemotion = function(x, y)
            -- update mouseX and mouseY for displaying location in status text
            mouseX, mouseY = screentomap(x, y)
            redraw()

            -- update selection
            if isSelectingPalette then
                updateSelection(x, y, true)
            elseif isSelectingMap then
                updateSelection(x, y)
            elseif isMouseDown then
                -- draw and update map selection
                mapSelection = {x=mouseX, y=mouseY, w=1, h=1}
                edit.drawTilesFromPalette()
            end
        end,

        mousewheel = function(x, y)
            if y > 0 then
                viewScale = viewScale * 2
            elseif y < 0 then
                viewScale = viewScale / 2
                if viewScale < 0.125 then
                    viewScale = 0.125
                end
            else
                return
            end
            engine:setScale(viewScale, viewScale)
            screenW, screenH = engine:getSize()
            paletteRect = getPaletteRect()
            redraw()
        end,

        quit = function()
            engine:stop()
        end
    }
end

do
    print('test')
    -- get arguments
    local printUsage = function(msg)
        print(msg)
        local usageprefix = arg[0]..' '..arg[1]..' '
        print('To edit an existing map: '..usageprefix..'<mapfile> <tileset>')
        print('To create a new map: '..usageprefix..'<mapfile> <tileset> <layers> <w> <h>')
    end

    -- next two should always be present
    local mapFilename, tilesetFilename = arg[2], arg[3]
    if not (mapFilename and tilesetFilename) then
        return printUsage('Please provide a map file and tileset')
    end

    -- dimensions (for creating new map)
    local numLayers, w, h = tonumber(arg[4]), tonumber(arg[5]), tonumber(arg[6])
    
    local tilemap
    if numLayers and w and h then
        tilemap, err = Tilemap{nlayers = numLayers, w = w, h = h}
        if tilemap and numLayers > 1 then
            tilemap:clean(6,0)
        end
    else
        tilemap, err = Tilemap{file = mapFilename}
    end

    if err then
        return print('Failed to create/open map: '..err)
    end

    -- Create window etc.
    local engine, err = Engine{
        title = 'map editor',
        --w=400, h=300, --windowflags = ant.engine.fullscreen,
        windowflags = ant.engine.fullscreendesktop,
        targetfps = 30
    }
    if err then
        return print('Failed to create window: '..err)
    end

    --engine:setScale(4, 4)

    -- Load tileset
    local tileset, err = Image{file = tilesetFilename, engine = engine}
    if err then
        return print('Failed to load tileset: '..err)
    end

    -- Run editor
    editor(engine, tilemap, tileset, mapFilename)
end

